
gameLog = {
  events = {}
}

logCursor = 1

function gameLogAppend(event)
  if logCursor < #gameLog.events then
    -- maybe trigger a confirm dialog here and revert move if user
    -- decides to abort
    broadcastToAll("history diverges, removing future events", {1,1,1})
    for i=#gameLog.events, logCursor, -1 do
      table.remove(gameLog.events, i)
    end
  end
  event['ts'] = os.time(os.date("*t"))
  gameLog.events[logCursor] = event
  logCursor = logCursor + 1
end

function gameLogAppendRoll(params)
  event = {
    type = "roll",
    player = params.player,
    rolls = params.rolls,
  }
  gameLogAppend(event)
end

function gameLogAppendOperativeMoved(id, operative, coords, old_coords, player)
  event = {
    id = id,
    type = "move",
    coords = coords,
    old_coords = old_coords,
    distance = coords:distance(old_coords),
    player = player,
    operative = operative
  }
  gameLogAppend(event)
end

function gameLogAppendOperativeChangedState(event)
  event['type'] = 'operative-state-change'
  gameLogAppend(event)
end

function gameLogAppendStateChange(params)
  event = {
    type = "state-change",
    cur_guid = params.cur_guid,
    cur_stateId = params.cur_stateId,
    old_guid = params.old_guid,
    old_stateId = params.old_stateId
  }
  gameLogAppend(event)
end

function gameLogForward()
  if logCursor > #gameLog.events then
    broadcastToAll('Already at the end of game log', {1,1,1})
    return
  end
  local event = gameLog.events[logCursor]
  -- broadcastToAll(JSON.encode(event), {1,1,1})
  gameLogRedo(event)
  logCursor = logCursor + 1
end

function gameLogBack()
  if logCursor == 1 then
    broadcastToAll('Already at the begging of game log', {1,1,1})
    return
  end
  logCursor = logCursor - 1
  local event = gameLog.events[logCursor]
  gameLogUndo(event)
end

function gameLogRedo(event)
  if event.type == "move" then
    local obj = getObjectFromGUID(event.id)
    if obj then
      obj.setPosition(event.coords)
    else
      broadcastToAll("Missing object " .. event.id .. " was " .. event.operative, {1,1,1})
    end
  end
  if event.type == "roll" then
    broadcastToAll(event.player .. " rolled " .. JSON.encode(event.rolls), {1,1,1})
  end
  if event.type == "state-change" then
    local obj = getObjectFromGUID(event.old_guid)
    setStateWithoutGlobalEvent(obj, event.cur_stateId)
  end
  if event.type == "operative-state-change" then
    local obj = getObjectFromGUID(event.guid)
    obj.script_state = event.cur_state
    obj.call("loadState", {})
    Wait.frames(function() obj.call("refreshUI", {}) end, 1)
  end
end

function setStateWithoutGlobalEvent(object, stateId)
  -- disable global detection of object state change
  local desc = object.getName()
  broadcastToAll(desc .. " changed", {1,1,1})
  local guid = object.getGUID()
  Global.call("disableStateChangeFor", guid)
  object.setState(stateId)
  -- changing state will trigger the global state change event in next frame,
  -- so we actually need to prevent detecting that event and generate event logs
  -- maybe 2 frames end up not being not enough, but let's be optimistic :)
  Wait.frames(|| Global.call("enableStateChangeFor", guid), 2)
end

function gameLogUndo(event)
  if event.type == "move" then
    local obj = getObjectFromGUID(event.id)
    if obj then
      obj.setPosition(event.old_coords)
    else
      broadcastToAll("Missing object " .. event.id .. " was " .. event.operative, {1,1,1})
    end
  end
  if event.type == "roll" then
    broadcastToAll(event.player .. " had just rolled " .. JSON.encode(event.rolls), {1,1,1})
  end
  if event.type == "state-change" then
    local obj = getObjectFromGUID(event.cur_guid)
    setStateWithoutGlobalEvent(obj, event.old_stateId)
  end
  if event.type == "operative-state-change" then
    local obj = getObjectFromGUID(event.guid)
    obj.script_state = event.old_state
    obj.call("loadState", {})
    Wait.frames(function() obj.call("refreshUI", {}) end, 2)
  end
end
