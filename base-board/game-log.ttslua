
local list = require 'lib/linkedlist-master/linkedlist'

local eventList = list()
local eventCursor = nil

function gameLogToDict()
  local obj = {}
  local i = 1
  for event in eventList:items() do
    local temp = {}
    for k, v in pairs(event) do
      if k != '_prev' and k != '_next' then
        temp[k] = v
      end
    end
    obj[i] = temp
    i = i + 1
  end
  return obj
end

function loadGameLogFromDict(gameLogDict)
  if gameLogDict == nil then
    eventList = list()
    return
  end
  for _, event in ipairs(gameLogDict) do
    -- this is being super paranoid to not reuse same object references I get
    local t = {}
    for k, v in pairs(event) do
      t[k] = v
    end
    eventList:insert_last(t)
  end
  eventCursor = eventList.last
end

function gameLogAppend(event)
  if eventCursor != eventList.last then
    -- maybe trigger a confirm dialog here and revert move if user
    -- decides to abort
    broadcastToAll("history diverges, removing future events", {1,1,1})
    while eventList.last != eventCursor do
      eventList:remove_last()
    end
  end
  event['ts'] = os.time(os.date("*t"))

  event_clone = {}
  for k, v in pairs(event) do
    event_clone[k] = v
  end

  eventList:insert_after(eventCursor, event_clone)
  eventCursor = eventList:next(eventCursor)
end

function gameLogAppendRoll(params)
  event = {
    type = "roll",
    player = params.player,
    rolls = params.rolls,
  }
  gameLogAppend(event)
end

function gameLogAppendOperativeMoved(id, operative, coords, old_coords, player)
  event = {
    id = id,
    type = "move",
    coords = coords,
    old_coords = old_coords,
    distance = coords:distance(old_coords),
    player = player,
    operative = operative
  }
  gameLogAppend(event)
end

function gameLogAppendOperativeChangedState(event)
  event['type'] = 'operative-state-change'
  gameLogAppend(event)
end

function gameLogAppendStateChange(params)
  event = {
    type = "state-change",
    cur_guid = params.cur_guid,
    cur_stateId = params.cur_stateId,
    old_guid = params.old_guid,
    old_stateId = params.old_stateId
  }
  gameLogAppend(event)
end

function gameLogForward()
  if eventCursor == eventList.last then
    broadcastToAll('Already at the end of game log', {1,1,1})
    return
  end
  if eventCursor == nil then
    eventCursor = eventList.first
  else
    eventCursor = eventList:next(eventCursor)
  end
  local event = eventCursor
  gameLogRedo(event)
end

function gameLogBack()
  if eventCursor == nil then
    broadcastToAll('Already at the beggining of game log', {1,1,1})
    return
  end
  local event = eventCursor
  gameLogUndo(event)
  eventCursor = eventList:prev(eventCursor)
end

function gameLogReset()
  eventList:clear()
  eventCursor = nil
end

function gameLogRedo(event)
  if event.type == "move" then
    local obj = getObjectFromGUID(event.id)
    if obj then
      obj.setPosition(event.coords)
    else
      broadcastToAll("Missing object " .. event.id .. " was " .. event.operative, {1,1,1})
    end
  end
  if event.type == "roll" then
    broadcastToAll(event.player .. " rolled " .. JSON.encode(event.rolls), {1,1,1})
  end
  if event.type == "state-change" then
    local obj = getObjectFromGUID(event.old_guid)
    setStateWithoutGlobalEvent(obj, event.cur_stateId)
  end
  if event.type == "operative-state-change" then
    local obj = getObjectFromGUID(event.guid)
    obj.script_state = event.cur_state
    obj.call("loadState", {})
    Wait.frames(function() obj.call("refreshUI", {}) end, 1)
  end
end

function setStateWithoutGlobalEvent(object, stateId)
  -- disable global detection of object state change
  local desc = object.getName()
  broadcastToAll(desc .. " changed", {1,1,1})
  local guid = object.getGUID()
  Global.call("disableStateChangeFor", guid)
  object.setState(stateId)
  -- changing state will trigger the global state change event in next frame,
  -- so we actually need to prevent detecting that event and generate event logs
  -- maybe 2 frames end up not being not enough, but let's be optimistic :)
  Wait.frames(|| Global.call("enableStateChangeFor", guid), 2)
end

function gameLogUndo(event)
  if event.type == "move" then
    local obj = getObjectFromGUID(event.id)
    if obj then
      obj.setPosition(event.old_coords)
    else
      broadcastToAll("Missing object " .. event.id .. " was " .. event.operative, {1,1,1})
    end
  end
  if event.type == "roll" then
    broadcastToAll(event.player .. " no longer rolled " .. JSON.encode(event.rolls), {1,1,1})
  end
  if event.type == "state-change" then
    local obj = getObjectFromGUID(event.cur_guid)
    setStateWithoutGlobalEvent(obj, event.old_stateId)
  end
  if event.type == "operative-state-change" then
    local obj = getObjectFromGUID(event.guid)
    obj.script_state = event.old_state
    obj.call("loadState", {})
    Wait.frames(function() obj.call("refreshUI", {}) end, 2)
  end
end
