local tokensToIgnore = {
    "Injured_red",
    "Injured_blue",
    "Minus_1_red",
    "Minus_1_blue",
    "Plus_1_red",
    "Plus_1_blue"
}

function utils_Set(list)
    local set = {}
    for _, l in ipairs(list) do set[l] = true end
    return set
end

local _tokensToIgnore = utils_Set(tokensToIgnore)

function onObjectLeaveContainer(container, object)
    if object.hasTag('KTUIToken') and not _tokensToIgnore[object.getName()] and object.getLuaScript() == "" then
        object.setScale({0.43,1,0.43}) -- 40mm tokens for KT24
        object.setLuaScript([[
            self.max_typed_number = 20

            modelMeasureLineRadius = 0.05
            base                   = {}
            baseLineRadius         = 0.0125
            baseLineHeight         = 0.1
            
            rangeShown             = false
            measureColor           = nil
            measureRange           = 0
            
            function onNumberTyped( pc, n )
                rangeShown = n > 0
                measureColor = Color.fromString(pc)
                measureRange = n
            
                scaleFactor = 1/self.getScale().x
            
                if lastRange == measureRange then
                sphereRange = getCircleVectorPoints(measureRange + 0.05, 0.125, 1)[1].x * 2 / scaleFactor
                Physics.cast({
                        origin       = self.getPosition(),
                        direction    = {0,1,0},
                        type         = 2,
                        size         = {sphereRange,sphereRange,sphereRange},
                        max_distance = 0,
                        debug        = true,
                    })
                end
                lastRange = measureRange
                refreshVectors(pc)
                --Player[pc].broadcast(string.format("%d\"", measureRange))
            end
            
            
            function refreshVectors(pc, norotate)
                local op = Player[pc]
                local circ = {}
                local scaleFactor = 1/self.getScale().x
            
                local rotation = self.getRotation()
            
                local newLines = {
                {
                    points = getCircleVectorPoints(0 - baseLineRadius, baseLineHeight),
                    color = op and Color.fromString(op.color) or {0.5, 0.5, 0.5},
                    thickness = baseLineRadius*2*scaleFactor
                }
                }
            
                if rangeShown then
                if measureRange > 0 then
                    table.insert(newLines,{
                    points=getCircleVectorPoints(measureRange - modelMeasureLineRadius + 0.05, 0),
                    color = measureColor,
                    thickness = modelMeasureLineRadius*2*scaleFactor,
                    rotation = (norotate and {0, 0, 0} or {-rotation.x, 0, -rotation.z})
                    })
                else
                    for _,r in pairs(ranges) do
                    local range = r.range
                    table.insert(newLines,{
                        points=getCircleVectorPoints(range - modelMeasureLineRadius + 0.05, 0),
                        color = r.color,
                        thickness = modelMeasureLineRadius*2*scaleFactor,
                        rotation = (norotate and {0, 0, 0} or {-rotation.x, 0, -rotation.z})
                        }
                    )
                    end
                end
                end
            
                self.setVectorLines(newLines)
            end
            
            function getCircleVectorPoints(radius, height, segments)
                local bounds = self.getBoundsNormalized()
                local result = {}
                local scaleFactorX = 1/self.getScale().x
                local scaleFactorY = 1/self.getScale().y
                local scaleFactorZ = 1/self.getScale().z
                local steps = segments or 64
                local degrees,sin,cos,toRads = 360/steps, math.sin, math.cos, math.rad
                --local modelBase = self.getPosition()
                local modelBase = {x=40,y=0,z=40}
            
                local mtoi = 0.0393701
                local baseX = modelBase.x * 0.5 * mtoi
                local baseZ = modelBase.z * 0.5 * mtoi
            
                for i = 0,steps do
                    table.insert(result,{
                        x = cos(toRads(degrees*i))*((radius+baseX)*scaleFactorX),
                        z = sin(toRads(degrees*i))*((radius+baseZ)*scaleFactorZ),
                        y = height*scaleFactorY
                    })
                end
            
                return result
            end         
        ]])
    end
end
